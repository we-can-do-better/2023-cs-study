# Thread Pool

## 짧은 답변

<aside>
💡 스레드 풀이란 **미리 만들어둔 스레드를 허용된 개수 안에서 사용하도록 제한하는 시스템**이며, 동시 요청을 안정적으로 처리해야하는 웹 서버에서 스레드 풀을 사용합니다. 스프링 부트는 스레드 풀 구현체를 가지고 있는 톰캣의 서블릿 컨테이너를 내장하고 있습니다. 따라서, 스레드 풀에 대해, 최대 스레드 수, 최소 스레드 수, 최대 커넥션 수, 대기열의 크기를 설정해 보다 성능과 안정성을 개선할 수 있습니다.

</aside>

## 기본 개념

---

### Program

컴퓨터가 실행할 수 있는 명령어들의 집합

### Process

컴퓨터에서 실행 중인 프로그램

각각의 프로세스는 **독립된 메모리 공간**을 할당 받는다.

![Untitled](Thread%20Pool%20e0a74875e14140b285ee2d0e21f996aa/Untitled.png)

### Thread

CPU에서 실행되는 단위(Unit of execution)

프로세스는 1개 이상의 스레드를 가질 수 있다.

### 단일 프로세스 시스템

한 번에 하나의 프로그램만 실행된다.

**단점**

⇒ CPU 사용률이 좋지 않다.

### 멀티 프로그래밍

여러개의 프로그램을 메모리에 올려놓고, 동시에 실행시킨다.

→ 단일 프로세스 시스템의 단점 개선 : CPU 사용률 개선

**단점**

⇒ CPU 사용시간이 길어지면 다른 프로세스가 계속 대기한다.

### 멀티 태스킹

프로세스가 한번 CPU를 사용할 때, 아주 짧은 시간만 CPU에서 실행되도록 한다.

특징

1. 하나의 CPU에 대해, 프로세스 간 컨텍스트 스위칭이 일어난다.
2. 멀티 스레드 환경의 경우, 여러 프로세스와 여러 스레드의 컨텍스트 스위칭이 일어남
3. 프로세스의 응답 시간 개선

**단점**

1. 하나의 프로세스가 동시에 여러 작업을 수행하지 못한다.
2. 프로세스의 컨텍스트 스위칭은 무거운 작업이다.
3. 프로세스 끼리 데이터 공유가 까다롭다. : 프로세스가 차지하는 메모리 공간은 공유되지 않는 독립된 공간이기 때문이다.

⇒ 따라서, 프로세스가 동시에 여러 작업을 수행하기 위해 여러 프로세스로 구성하는 경우는 비효율적이다.

### 멀티 스레딩

하나의 프로세스가 동시에 여러 작업을 실행한다.

**특징**

1. 같은 프로세스의 스레드 간 컨텍스트 스위칭은 가벼운 작업이다.
2. 스레드는 자신이 속한 같은 프로세스의 힙 메모리 영역을 공유할 수 있다.

   1. code, data(전역변수), heap(런타임 동적 할당) 영역은 공유하고, 각 스레드는 스택 영역을 할당 받는다.

   ![Untitled](Thread%20Pool%20e0a74875e14140b285ee2d0e21f996aa/Untitled%201.png)

   ![Untitled](Thread%20Pool%20e0a74875e14140b285ee2d0e21f996aa/Untitled%202.png)

### 멀티 프로세싱

두 개 이상의 프로세서나 코어를 활용하는 시스템

### User Thread

OS Thread에 대한, 유저 프로그램 계층에서의 추상화

### One-to-One Threading Model

유저 스레드가 하나 생길 때, 그에 해당하는 OS 스레드 하나를 꼭 연결해줘야한다.

ex ) Java

- 자바에서는 유저 스레드를 새로 생성하면, OS 커널 레벨에 있는 OS 스레드와 꼭 하나가 연결되어야한다.

### 자바와 멀티스레드

자바 기반의 웹 어플리케이션 서버로, 클라이언트가 요청을 보내면, WAS는 어플리케이션 코드라인 한줄씩에 대하여 스레드를 할당한다. 이 스레드는 서블릿을 호출하고, 서블릿은 클라이언트로 요청에 대한 응답을 반환한다.

![Untitled](Thread%20Pool%20e0a74875e14140b285ee2d0e21f996aa/Untitled%203.png)

이때, 여러가지 요청을 동시에 처리하려면 스레드를 추가적으로 생성하여 실행하게되고, 멀티 스레드 환경이 구성된다.

![Untitled](Thread%20Pool%20e0a74875e14140b285ee2d0e21f996aa/Untitled%204.png)

## Thread를 사용한 병렬 작업 처리

---

### 단순하게 Thread를 사용하는 전략

요청이 올 때마다, 새로운 스레드를 생성해서 작업을 처리하고, 처리가 끝난 스레드는 없애는 방식으로 동작하는 자바 기반의 프로세스가 있다고 가정한다.

**문제점**

1. 스레드를 생성비용이 커, 요청에 대한 응답시간이 증가한다.
   1. 자바에서는 One-to-One Threading Model을 쓰고 있어 유저 스레드당 꼭 하나의 OS 스레드를 연결한다.
   2. 새로운 스레드를 생성하는 작업은 OS 커널의 작업이 동반되므로 생성 비용이 큰 것이다.
   3. **작업을 요청할 때 마다 스레드를 생성하는 것은, 생성 비용까지의 오버헤드를 감당해야한다.**
2. 스레드가 너무 많으면 여러 SideEffect가 발생한다.
   1. 프로세스의 처리 속도보다 빠르게 요청이 들어올 경우, 새로운 스레드가 계속 생성된다.
   2. 스레드가 많아질수록, 메모리를 차지해 **메모리 문제**가 발생할 수 있다.
   3. 스레드가 많아질 수록, 컨텍스트 스위칭이 더 자주 발생해, **CPU 오버헤드**가 발생할 수 있다.

### Thread Pool

미리 만들어둔 Thread를 허용된 개수 안에서 사용하도록 제한하는 시스템

![Untitled](Thread%20Pool%20e0a74875e14140b285ee2d0e21f996aa/Untitled%205.png)

**스레드 풀의 구성요소**

1. 스레드 작업을 할 스레드들
2. 작업 큐 ( Work queue )

**스레드 풀의 작업 처리 순서**

1. 스레드 풀에 작업 처리 요청
2. 요청된 작업을 **작업 큐**에 보관
3. 작업큐의 작업들을 하나씩 스레드로 할당하여 스레드에서 작업 처리
4. 클라이언트에 결과를 전달하고, **작업 처리를 완료한 스레드는 작업 큐로부터 그 다음 작업을 받아 처리**

**특징**

1. 메모리 문제와 CPU 오버헤드 방지 : 사용할 **스레드의 개수를 제한**한다.
2. 작업 마다의 **스레드 생성 비용이 없어** 요청 처리 시간이 감소한다 : 스레드를 미리 만들어 두며, 한 번 사용된 스레드가 작업이 끝난 이후에도 없어지지 않고, 재사용이 가능하다.

### Java의 Thread Pool

자바에서는, `ThreadPoolExecutor` 클래스를 통해 스레드 풀을 구현한다.

**설정 요소**

1. `maximunPoolSize`
   - 스레드 풀은 최대 maxPoolSize 개수 만큼의 스레드를 가질 수 있다.
   - 하지만, 스레드 풀은 스레드를 미리 생성하지만, 최대 양 만큼 생성하지는 않는다.
2. `keepAliveTime`
   - keepAliveTime 시간 이후로도 계속 작업 큐에 작업이 없다면, 스레드가 없어진다.
3. `corePoolSize`
   - keepAliveTime 에 따라 스레드가 없어질 때, corePoolSize 만큼 없어진다.

### Tomcat의 Thread Pool

Tomcat

- Spring boot 내장 서블릿 컨테이너 중 하나
- Java 기반의 WAS
- Java의 Thread Pool 클래스와 매우 유사한 형태의 자체 Thread Pool 구현체를 가지고 있다.

설정 요소

1. `maxThreads`
   - Tomcat의 스레드 풀은 최대 maxTreads 개수 만큼의 스레드를 가질 수 있다.
2. `maxConnections`
   - 최대로 maxConnections 수 만큼 동시에 처리할 수 있다.
   - 요청이 들어오면, Tomcat의 Connector가 Connection을 생성하면서 요청된 작업을 Thread Pool의 Thread에 연결한다.
3. `acceptCount`
   - maxConnections 이상의 요청이 들어왔을 때, acceptCount 만큼의 크기의 큐에 보관한다.
   - acceptCount 를 초과한 요청은 거절될 수 있다.

## 효과적인 Thread Pool 사용

---

### SpringBoot 설정

1. `server.tomcat.threads.max`
   - 스레드 풀에서 사용할 수 있는 최대 스레드 개수 ( default : 200 )
   - 요청 수에 비해 너무 많게 설정할 경우 : 사용하지 않는 스레드가 많아 비효율적이다.
   - 요청 수에 비해 너무 적게 설정할 경우 : 동시 처리 요청수가 줄어들어, 평균 응답 시간과 tps ( 초당 트랜잭션 개수 ) 가 감소한다.
2. `server.tomcat.threads.min-spare`
   - 스레드 풀에서 사용할 수 있는 최소한의 스레드 개수 ( default : 10 )
   - 요청 수에 비해 너무 많게 설정할 경우 : 항상 유지할 스레드 수가 너무 많다. 메모리의 비효율이 발생한다.
   - 적절하게 설정할 경우 : 적은 수의 요청에서 새로운 스레드를 만들필요 없이 요청을 효과적으로 처리할 수 있다.
3. `server.tomcat.threads.max-connections`
   - 동시에 처리할 수 있는 최대 Connection의 수 ( default : 8192 )
   - Blocking IO의 경우 : 하나의 스레드에 하나의 커넥션이 연결되므로, 최대 스레드 수와 최대 커넥션 수가 같아야한다.
   - Non Blocking IO의 경우 : 하나의 스레드에 여러개의 커넥션이 연결되므로, 동시적으로 작업을 처리할 수 있다. 최대 스레드 수 < 커넥션 수 일때 효과적으로 처리한다.
   - Tomcat 8 이후는 Non Blocking IO를 채택하고 있다.
4. `server.tomcat.threads.accept-count`
   - max-connections 이상의 요청이 들어왔을 때 사용하는 대기열 queue 사이즈 ( default : 100 )
   - 너무 크게 설정할 경우 : 메모리 문제를 유발한다.
   - 너무 작게 설정할 경우 : 요청이 몰렸을 때 많은 요청을 거절한다.
   - 부적절하거나, 잘못된 요청이 한번에 너무 많이 들어와 서버에 장애를 발생시키는 것을 방지할 수 있다.

### 스레드 풀 설정이 필요한 이유

1. 스레드 풀은 응답시간과 TPS에 영향을 준다.
2. 스레드 풀을 잘 설정하면, 시스템의 성능을 개선하고, 높은 안정성을 제공한다.
3. 스레드 풀을 부적절하게 설정하면, 병목 현상, CPU 오버헤드, 메모리 문제가 발생한다.

## Node.js와 Single Thread, Multi Thread

---

### 이벤트 주도 방식과 Non-Blocking을 사용하는 Node.js

일반적으로 운영체제는 스레드 기반의 동시성 모델을 사용한다. 작업의 수만큼 스레드를 할당하고 컨텍스트 스위칭한다.

이러한 방식은 이벤트 주도 방식 ( Event-Driven Architecture ) 에 비해 다음의 단점을 가지고 있다.

1. 자원의 낭비가 발생한다.
2. 개발자가 다루기 어렵다.
3. 데드락을 발생시킨다.

따라서, Node.js는 멀티스레드 기반 동시성 모델 대신, 싱글 스레드를 효율적으로 사용할 수 있는 이벤트 루프를 선택했다.

그리고, Node.js는 Non-Blocking으로 동작한다. 비동기 작업들로 맡기고 이후 코드를 진행하는 것이다.

### 싱글스레드에서의 비동기 작업 처리

하지만, 자바스크립트는 싱글 스레드 언어인데, 어디서 비동기 작업들을 처리하고 있는걸까? 바로 이벤트 루프이다.

![Untitled](Thread%20Pool%20e0a74875e14140b285ee2d0e21f996aa/Untitled%206.png)

![Untitled](Thread%20Pool%20e0a74875e14140b285ee2d0e21f996aa/Untitled%207.png)

Node.js는 자바스크립트 기반의, Event Loop의 싱글 스레드를 가진 언어이나, 멀티 스레딩을 지원하는 C언어 라이브러리 libuv 를 사용한다. Node.js의 libuv는 기본적으로 4개의 스레드를 가진 스레드풀을 가지고 있다.

따라서, 동기적인 작업은 이벤트 루프에서 작업하며, 비동기적인 작업은 스레드 풀에서 작업한다.

**결론적으로, Node.js는 싱글스레드의 자바스크립트 기반 언어이므로, 기본적으로는 싱글스레드 언어이나, 비동기 작업을 수행할 때에는 멀티 스레드 프로세스이다.**
