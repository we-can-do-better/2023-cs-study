## 가상 메모리란?

컴퓨터에서 주 기억장치(RAM)와 보조 기억장치(HDD)를 하나로 봐서, **주 기억장치보다 크기가 큰 프로세스를 실행할 수 있는 기능을 제공하는 기법**이다.

### **어떻게 주 기억장치보다 큰 프로세스를 실행할 수 있을까?**

애플리케이션이 실행될 때, 실행에 필요한 페이지만 주 기억장치에 올라가도록 한다. 이를 가능하게 하는 것이 가상 메모리 관리 기법과 MMU이다. 먼저 가상 메모리 관리 기법에 대해 이해하고 알아보도록 하자.

## 가상 메모리 관리 기법

운영체제에서 가상 메모리를 관리하는 기법에는 Paging과 Segmentation이 있다.

### **Paging 기법**

Paging은 가상 메모리의 논리 주소를 고정된 크기의 **페이지**로 나누고 각각 물리 메모리의 고정된 크기의 **프레임**과 매핑하는 방식이다. 매핑된 정보가 페이지 테이블에 저장되고 이를 통해 물리 주소에 접근하는 방식이다.

**Paging 기법은, 내부 단편화가 발생하지만 외부 단편화는 발생하지 않는다는 특징이 있다.**

> **내부 단편화가 발생한다**
페이지 크기가 고정되어 있어, 적재되는 프로세스가 페이지 크기보다 작을 경우 페이지 내부에 낭비되는 메모리가 발생한다.
>
> <img width="699" alt="1" src="https://github.com/blacktokkies/toquiz/assets/72093196/8fda715d-5880-4a67-9162-129bab2f3e87">
> 
>
> **외부 단편화 발생하지 않는다**
> 페이지 크기가 고정되어 있어, 크기가 일정하게 적재된다. 그래서 빈 공간이 있으면 무조건 페이지가 들어갈만한 사이즈가 충족된다.
>
> <img width="299" alt="2" src="https://github.com/blacktokkies/toquiz/assets/72093196/b69819e8-aaeb-49de-8cba-0a90c8c4ea54">
>

### Segmentation 기법

Segmentation은 가상 메모리의 논리 주소를 **논리적 내용을 기반**으로 세그먼트라는 단위로 나누고 **세그먼트 번호와 오프셋**을 통해 물리 주소에 접근하는 방식이다.

**외부 단편화가 발생하지만 내부 단편화는 발생하지 않는다는 특징이 있다.**

> **외부 단편화가 발생한다**
페이지 크기가 고정되어 있지 않아, 세그먼트가 할당되고 반환하는 과정이 반복되다 보면 연속되지 않는 빈 공간들이 생긴다. 메모리에 세그먼트가 적재될 수 있는 용량이 있더라도 들어갈 수 있는 공간이 존재하지 않을 수 있다.
>
>
> <img width="595" alt="3" src="https://github.com/blacktokkies/toquiz/assets/72093196/835fe977-bf16-442b-86f8-9d1a98cdb44e">
>
> **내부 단편화는 발생하지 않는다**
> 논리적인 단위로 데이터를 나누기 때문에 세그먼트 내에 빈 공간이 존재하지 않는다
>
- **참고) 세그먼트를 저장할 때 정책 (First-Fit, Best-Fit, Worst-Fit)**
    - First-Fit(최초 적합) : 세그먼트를 수용할 수 있는 공간 중 가장 처음에 나오는 공간에 저장
    - Best-Fit(최적 적합) : 세그먼트를 수용할 수 있는 공간 중 가장 작은 공간에 저장
    - Worst-Fit(최악 적합) : 세그먼트를 수용할 수 있는 공간 중 가장 큰 공간에 저장

      <img width="553" alt="7" src="https://github.com/blacktokkies/toquiz/assets/72093196/e97790af-c286-4407-8312-492cf89b3d01">


### 주소 공간을 Page와 Segment로 나누는 이유

프로세스에서 할당받은 메모리 영역을 전부 물리 메모리에 올리지 않고 일부만 올리기 위해서 사용된다.

## MMU

MMU는 메모리를 관리하는 유닛이다. MMU의 기능은 다음과 같다.

- **가상 주소와 물리 주소 매핑**
- 메모리 보호 기능 (프로세스가 할당 받지 않은 물리 메모리에 접근하지 못하도록 함)

프로그램이 실행 중에 메모리에 접근할 때, MMU를 통해 가상 주소를 물리 주소로 바꿔 접근한다.
메모리에 접근할 때마다 메모리를 일일이 가상 주소에서 물리 주소로 변환하는 과정을 거쳐야 한다.

paging 기법을 사용할 경우 **페이지 테이블**을 참조하여 변환한다.

### 페이지 테이블 (Page Table)

페이지 테이블은 가상 주소(페이지)와 물리 주소(프레임)를 매핑한 테이블이다.



> **가상 주소 변환 과정**
>
>
> 먼저 가상 주소의 페이지 번호를 페이지 테이블에서 조회하고, 해당 페이지에 대응하는 물리 주소인 프레임 번호를 얻는다. 그리고 오프셋을 사용하여 물리 프레임 내에서 실제 데이터에 접근한다.
>

페이지 테이블은 주 기억장치에 위치한다. 자주 사용되는 주소 변환 결과를 CPU에 캐싱하여 빠르게 접근할 수 있다. 이를 가능하게 하는 것이 **TLB**이다.

### TLB

가상 주소와 물리 주소 간의 변환 결과를 저장하는 **캐시**이다. CPU의 MMU에 내장되어 있다.

### TLB Miss와 페이지 폴트(Page Fault)

페이지 테이블에 존재하지 않는 페이지에 접근할 경우 페이지 폴트(Page Fault)가 발생한다. 페이지 폴트가 발생할 경우 어떻게 처리되는지 알아보도록 하자.

**페이지 접근**

<img width="608" alt="5" src="https://github.com/blacktokkies/toquiz/assets/72093196/a2c3fd99-ce55-48c4-96e4-7e97938a9932">

1. 먼저, CPU가 가상 주소를 MMU에게 요청한다.
2. MMU는 TLB에 요청받은 가상 주소의 주소 변환 결과(물리 주소)가 저장되어 있는지 확인한다.
3. TLB 저장 여부에 따라 다음으로 나뉜다.
    1. 저장되어 있으면, MMU가 해당 물리 주소로 데이터를 갖고 와서 CPU에게 보낸다.
    2. 저장되어 있지 않으면, MMU가 현재 실행 중인 프로세스의 페이지 테이블에 접근하기 위해 CR3 레지스터에 접근하여 확인한다. (CR3 레지스터에 현재 실행 중인 프로세스의 페이지 테이블 주소가 저장되어 있음)
4. MMU가 페이지 테이블에 가상 주소와 매핑된 물리 주소가 있는지 valid bit를 확인한다.
   (valid bit는 해당 페이지가 현재 주 기억장치에 적재되어 유효한지 상태를 나타내는 비트이다.)
    1. valid bit가 1이면, MMU가 해당 가상 주소와 매핑된 물리 주소를 데이터로 갖고 와서 CPU에게 보낸다.
    2. valid bit가 0이면, MMU가 페이지 폴트 인터럽트를 운영체제에 발생시킨다.

**페이지 폴트 인터럽트**

<img width="514" alt="6" src="https://github.com/blacktokkies/toquiz/assets/72093196/7ffcff36-6e82-4e0f-8877-a15e4125e413">

1. 운영체제가 해당 페이지에 해당하는 프레임을 저장 공간에서 가져온다.
2. 주 기억장치에 프레임을 적재할 수 있는 공간이 존재하는지에 따라 다음과 같이 나뉜다.
    1. 주 기억장치(메모리)에 프레임을 적재할 수 있는 공간이 있으면, 적재한다.
    2. 주 기억장치(메모리)에 프레임을 적재할 수 있는 공간이 없으면, 스왑 아웃을 통해 메모리 공간을 확보하여 적재한다.
3. 페이지 테이블을 업데이트한다. 그리고 valid bit를 1로 업데이트한다.
4. 운영체제가 CPU에게 프로세스를 다시 실행하라고 요청한다.


## Reference

[https://ahnanne.tistory.com/15#6. TLB(Translation Lookaside Buffer, 페이지 정보 캐쉬)란](https://ahnanne.tistory.com/15#6.%20TLB(Translation%20Lookaside%20Buffer,%20%ED%8E%98%EC%9D%B4%EC%A7%80%20%EC%A0%95%EB%B3%B4%20%EC%BA%90%EC%89%AC)%EB%9E%80)?

https://eunjinii.tistory.com/142