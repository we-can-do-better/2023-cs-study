## 이진 탐색 트리(Binary Search Tree)부터 B+Tree 까지

이진 탐색 트리(Binary Search Tree)란 이진 탐색(Binary Search)의 **효율적인 탐색**과 **빈번한 자료 입력과 삭제에 용이한** 연결 리스트(Linked List)의 장점을 결합한 자료구조의 일종이다. 

### 이진 탐색(Binary Search)
이진탐색이란 데이터가 정렬돼 있는 배열에서 특정한 값을 찾아내는 알고리즘이다.
```
1. 배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 X와 비교
2. X가 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로 하고, X가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색한다.
(해당 값을 찾을 때까지 이 과정을 반복)
```

한 가지 예시를 들어보겠다.
```
{ 17, 28, 43, 67, 88, 92, 100 }
```
이 배열에서 이진 탐색을 이용하여 43의 값을 과정은 다음과 같다.

```
찾고자 하는 값: 43
1. 43은 중간 값인 67보다 작으므로 좌측 배열 값들을 대상으로 탐색 {17, 28, 43}
2. 43은 좌측 배열의 중간 값인 28보다 크므로 우측 배열 값들을 대상으로 탐색 { 43 }
3. 배열에 값이 하나만 남게 되고, 값을 비교해보면 43 == 43으로 원하는 값을 찾게 되어 탐색 종료
```

이렇게 처음에 N개 크기의 배열에서 단계가 하나씩 지나감에 따라 탐색할 배열의 크기가 반씩 줄어들기 때문에 이진 탐색의 시간 복잡도는 O(log N)이다.<br/>
단, 이진 탐색은 정렬된 배열에서만 사용될 수 있다.


### 연결 리스트 (Linked List)
연결 리스트는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식의 자료구조이다.

![img.png](../image/이진 탐색 트리(Binary Search Tree)부터 B+Tree 까지-3.png)

이미지 출처: https://www.alphacodingskills.com/ds/notes/linked-list.php

연결 리스트는 포인터로 연결되어 있어서 가리키는 노드만 변경해주면 되기 때문에 삽입과 삭제가 용이하다.

![img.png](../image/이진%20탐색%20트리(Binary%20Search%20Tree)부터%20B+Tree%20까지-4.png)

이미지 출처: https://qnaplus.com/insert-element-singly-linked-list/

그래서 연결 리스트의 맨 앞/뒤에 데이터를 추가/삭제 하는 경우에 시간 복잡도가 O(1)이 소요되게 된다.<br/> 
단, 연결 리스트의 중간에 추가/삭제(탐색하는 시간) 또는 탐색의 경우에는 시간복잡도 O(n)이 소요된다.

```
이진탐색
- 장점 : 탐색에 소요되는 시간복잡도는 O(log n)으로 빠름

연결리스트
- 장점 : 자료 입력, 삭제에 필요한 시간복잡도는 O(1)로 빠름
```

### 이진 탐색 트리(Binary Search Tree)
이진 탐색 트리는 다음과 같은 형태를 띈 트리이다.

![이진 탐색 트리(Binary Search Tree)부터 B+Tree 까지-1.png](..%2Fimage%2F%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89%20%ED%8A%B8%EB%A6%AC%28Binary%20Search%20Tree%29%EB%B6%80%ED%84%B0%20B%2BTree%20%EA%B9%8C%EC%A7%80-1.png)


이진 탐색 트리는 다음과 같은 특징을 갖는 이진트리이다.
> 이진 트리(Binary Tree): 각 노드의 자식 노드가 최대 2개인 트리

```
1. 각 노드에 중복되지 않는 키(key)가 있다.
2. 루트 노드의 왼쪽 서브 트리는 해당 노드의 키보다 작은 키를 갖는 노드들로 이루어져 있다.
3. 루트 노드의 오른쪽 서브 트리는 해당 노드의 키보다 큰 키를 갖는 노드들로 이루어져 있다.
4. 좌우 서브 트리 전부는 이진 탐색 트리여야 한다.
```

이진 탐색 트리의 탐색 연산 시간 복잡도는 트리의 높이를 h(height)라고 한다면 $$O(h)$$의 시간 복잡도를 갖는다.

아래와 같은 트리가 존재한다고 했을 때, 키가 5인 노드를 찾고자 한다면 다음과 같은 순서를 거치게 된다.

```
찾고자 하는 값: 5
1. 5는 루트 노드의 키 값인 7보다 작으므로 왼쪽 서브 트리로 탐색
2. 5는 3보다 크므로 오른쪽 서브 트리로 탐색
3. 키가 5인 노드를 찾았으므로 탐색 종료
즉 트리 안의 값을 찾는다면 무조건 트리의 높이(h) 이하의 탐색($O(h)$)이 이루어진다. 
(트리 안에 찾고자 하는 값이 없더라도 최대 h 번 만큼만의 탐색이 진행된다.)
```

![img.png](../image/이진 탐색 트리(Binary Search Tree)부터 B+Tree 까지-2.png)

**하지만**

아래 이미의 우측 그림처럼 균형이 잡힌 이진 탐색 트리의 경우 시간 복잡도가 이진 탐색의 시간복잡도인 O(log n)이 되지만, 왼쪽 그림과 같이 균형이 잡히지 않은 이진 탐색의 경우 O(n)에 수렴하게 되면서 이진 탐색의 장점을 가졌다고 보기 어려웠다.

![img.png](../image/이진%20탐색%20트리(Binary%20Search%20Tree)부터%20B+Tree%20까지-5.png)

그래서 이를 해결하기 위한 여러 자료구조가 생겨나게 되었고 그중 하나가 B-tree이다.


### B-tree

B-tree는 다음과 같은 형태를 띈 자료구조이다.

![img_1.png](../image/이진%20탐색%20트리(Binary%20Search%20Tree)부터%20B+Tree%20까지-6.png)

이미지 출처: https://rebro.kr/169

[참고]
- [링크](https://cjh5414.github.io/binary-search/)